Attribute VB_Name = "MacroStats"
'------------------------------------------------------------------------------
' MacroStats
' A collection of statistics-related functions for Excel's VBA macro language.
'
' By Iain Dunning, 2011
' http://www.iaindunning.com
' https://github.com/IainNZ/MacroStats
'
'------------------------------------------------------------------------------
'
' Licensing: MIT License
'
' Copyright (c) 2011 Iain Dunning, http://www.iaindunning.com
'
' Permission is hereby granted, free of charge, to any person obtaining a copy
' of this software and associated documentation files (the "Software"), to deal
' in the Software without restriction, including without limitation the rights
' to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
' copies of the Software, and to permit persons to whom the Software is
' furnished to do so, subject to the following conditions:
'
' The above copyright notice and this permission notice shall be included in
' all copies or substantial portions of the Software.
'
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
' IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
' FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
' AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
' LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
' OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
' THE SOFTWARE.
'
'------------------------------------------------------------------------------
'
' Project layout:
' MacroStats.bas
'   - The library itself, IMPORT THIS INTO YOUR PROJECTS!
' MacroStats.xlsm
'   - The workbook used to develop the libary.
'   - Don't need to add this to you to your project.
' MacroStatsTest.bas
'   - Mainly used to aid development, not necessary to include in your
'     projects.
'   - Used to aid development by ensuring that the functions work as
'     promised. Ff you encounter a problem and report it to me, I'll
'     add a test that should ensure the problem is never reintroduced.
'
'------------------------------------------------------------------------------
Option Explicit
' PI to 15dp, as generated by Excel's Pi() function
Public Const MacroStatsPI As Double = 3.14159265358979

Public Function SampleDiscreteCDF( _
    ByRef CDF As Variant, _
    Optional ByVal RaiseError As Boolean = False _
) As Long
'------------------------------------------------------------------------------
' SampleDiscreteCDF
' Generate a random integer from a cumulative distribution function.
' For more information about CDFs:
' http://en.wikipedia.org/wiki/Cumulative_distribution_function
'
' Input:
'   CDF() as Variant
'       - A one-dimensional array of numbers that describe a CDF.
'   [Optional] RaiseError as Boolean
'       - Default = False
'       - If there is a problem with the CDF, and this value is true, then
'         an error will be raised so you can address it
'
' Return:
'   A random integer, chosen using the CDF.
'   The integer is taken from the array indices.
'
' Example Usage:
'   Dim myCDF(3 to 6) as Double
'   myCDF(3) = 0.1
'   myCDF(4) = 0.5
'   myCDF(5) = 0.9
'   myCDF(6) = 1.0
'   Debug.Print SampleDiscreteCDF(myCDF)
'   ' 10% chance of returning a 3, 40% chance of a 4, etc.
'
'------------------------------------------------------------------------------

    Dim R As Single
    R = Rnd()
    
    Dim i As Long
    For i = LBound(CDF) To UBound(CDF)
        If R <= CDF(i) Then
            SampleDiscreteCDF = i
            Exit Function
        End If
    Next i
    
    ' If we got to this point, it must not have been a valid CDF because
    ' the last element in the array was not a 1.
    If RaiseError Then
        Err.Raise vbObjectError + 1, "MacroStats.SampleDiscreteCDF", _
                  "Unable to sample from CDF - check last element is 1."
    End If
End Function


Public Function SampleDiscreteCDFon2D( _
    ByRef CDF As Variant, _
    ByVal FirstIndex As Long, _
    Optional ByVal RaiseError As Boolean = False _
) As Long
'------------------------------------------------------------------------------
' SampleDiscreteCDFon2D
' Generate a random integer from a cumulative distribution function.
' Use this when you have a 2D array, where the CDF is in the second dimension.
' For more information about CDFs:
' http://en.wikipedia.org/wiki/Cumulative_distribution_function
'
' Input:
'   CDF() as Variant
'       - A one-dimensional array of numbers that describe a CDF.
'   FirstIndex as Long
'       - The index in the first dimension of the array.
'   [Optional] RaiseError as Boolean
'       - Default = False
'       - If there is a problem with the CDF, and this value is true, then
'         an error will be raised so you can address it
'
' Return:
'   A random integer, chosen using the CDF.
'   The integer is taken from the array indices of the second dimension.
'
' Example Usage:
'   Dim myCDF(1 to 2, 3 to 6) as Double
'   myCDF(1,3) = 0.1: myCDF(2,3) = 0.4
'   myCDF(1,4) = 0.5: myCDF(2,4) = 0.5
'   myCDF(1,5) = 0.9: myCDF(2,5) = 0.9
'   myCDF(1,6) = 1.0: myCDF(2,6) = 1.0
'   Debug.Print SampleDiscreteCDFon2D(myCDF, 2)
'   ' 40% chance of returning a 3, 10% chance of a 4, etc.
'
'------------------------------------------------------------------------------

    Dim R As Single
    R = Rnd()
    
    Dim i As Long
    For i = LBound(CDF, 2) To UBound(CDF, 2)
        If R <= CDF(FirstIndex, i) Then
            SampleDiscreteCDFon2D = i
            Exit Function
        End If
    Next i
    
    ' If we got to this point, it must not have been a valid CDF because
    ' the last element in the array was not a 1.
    If RaiseError Then
        Err.Raise vbObjectError + 1, "MacroStats.SampleDiscreteCDFon2D", _
                  "Unable to sample from CDF - check last element is 1."
    End If
End Function


Public Function SampleDiscreteCDFon3D( _
    ByRef CDF As Variant, _
    ByVal FirstIndex As Long, _
    ByVal SecondIndex As Long, _
    Optional ByVal RaiseError As Boolean = False _
) As Long
'------------------------------------------------------------------------------
' SampleDiscreteCDFon3D
' Generate a random integer from a cumulative distribution function.
' Use this when you have a 3D array, where the CDF is in the third dimension.
' For more information about CDFs:
' http://en.wikipedia.org/wiki/Cumulative_distribution_function
'
' Input:
'   CDF() as Variant
'       - A one-dimensional array of numbers that describe a CDF.
'   FirstIndex as Long
'       - The index in the first dimension of the array.
'   SecondIndex as Long
'       - The index in the second dimension of the array.
'   [Optional] RaiseError as Boolean
'       - Default = False
'       - If there is a problem with the CDF, and this value is true, then
'         an error will be raised so you can address it
'
' Return:
'   A random integer, chosen using the CDF.
'   The integer is taken from the array indices of the third dimension.
'
' Example Usage:
'   Dim myCDF(9 to 9, 1 to 2, 3 to 6) as Double
'   myCDF(9,1,3) = 0.1: myCDF(9,2,3) = 0.4
'   myCDF(9,1,4) = 0.5: myCDF(9,2,4) = 0.5
'   myCDF(9,1,5) = 0.9: myCDF(9,2,5) = 0.9
'   myCDF(9,1,6) = 1.0: myCDF(9,2,6) = 1.0
'   Debug.Print SampleDiscreteCDFon2D(myCDF, 9, 2)
'   ' 40% chance of returning a 3, 10% chance of a 4, etc.
'
'------------------------------------------------------------------------------

    Dim R As Single
    R = Rnd()
    
    Dim i As Long
    For i = LBound(CDF, 3) To UBound(CDF, 3)
        If R <= CDF(FirstIndex, SecondIndex, i) Then
            SampleDiscreteCDFon3D = i
            Exit Function
        End If
    Next i
    
    ' If we got to this point, it must not have been a valid CDF because
    ' the last element in the array was not a 1.
    If RaiseError Then
        Err.Raise vbObjectError + 1, "MacroStats.SampleDiscreteCDFon3D", _
                  "Unable to sample from CDF - check last element is 1."
    End If
End Function


Public Function FlipCoin( _
    ByVal Probability As Double _
) As Boolean
'------------------------------------------------------------------------------
' FlipCoin
' Returns a true with the provided probability.
'
' Input:
'   Probability as Double
'       - The probability we are using to generate the True/False
'
' Return:
'   True or False, with probability provided.
'
' Example Usage:
'   Debug.Print FlipCoin(0.5)
'   ' Like flipping a coin, 50/50 of being True
'   Debug.Print FlipCoin(0.6) ' 60/40..., etc.
'
'------------------------------------------------------------------------------
    
    FlipCoin = (Rnd() < Probability)
    
End Function


Public Function FitNormalDistributionToData( _
    ByRef data As Variant, _
    ByRef mean As Double, _
    ByRef stddev As Double _
) As Boolean
'------------------------------------------------------------------------------
' FitNormalDistributionToData
' Fits a normal distribution to a data set provided by the user.
' Uses Maximum Likelihood Estimation:
'   - http://en.wikipedia.org/wiki/Maximum_likelihood
'
' Input:
'   data As Variant
'       - A one dimensional array of numbers
'
' Output:
'   mean as Double
'   stddev as Double
'       - The fitted parameters of the normal distribution
'
' Return:
'   True if succesfully fitted, False if not possible.
'
' Example Usage:
'   Dim normMean As Double, normStdDev As Double
'   If MacroStats.FitNormalDistributionToData(data, normMean, normStdDev) Then
'       Debug.Print "Fitted! Mean [3] = "; normMean; ", SD = "; normStdDev
'   Else
'       Debug.Print "Fitting error!"
'   End If
'
'------------------------------------------------------------------------------
    On Error GoTo normalFitError

    Dim i As Integer, n As Integer
   
    ' Data size
    n = UBound(data) - LBound(data) + 1
   
    ' Mean
    mean = 0
    For i = LBound(data) To UBound(data)
        mean = mean + data(i)
    Next i
    mean = mean / n
    
    ' Standard Deviation
    stddev = 0
    For i = LBound(data) To UBound(data)
        stddev = stddev + (data(i) - mean) ^ 2
    Next i
    stddev = (stddev / n) ^ 0.5
    
    FitNormalDistributionToData = True
    Exit Function
    
normalFitError:
    mean = 0
    stddev = 0
    FitNormalDistributionToData = False
End Function


Public Function FitNormalDistributionToPercentiles( _
    ByVal X1 As Double, ByVal P1 As Double, _
    ByVal X2 As Double, ByVal P2 As Double, _
    ByRef mean As Double, _
    ByRef stddev As Double _
) As Boolean
'------------------------------------------------------------------------------
' FitNormalDistributionToPercentiles
' Fits a normal distribution to two percentiles.
'   - http://www.johndcook.com/quantiles_parameters.pdf
'
' Input:
'   X1 as Double, P1 as Double
'   X2 as Double, P2 as Double
'       - Percentile #1 and #2, e.g.
'         50th percentile is 60 => X1 = 60, P1 = 0.5
'         84th percentile is 80 >= X2 = 80, P2 = 0.84
'
' Output:
'   mean as Double
'   stddev as Double
'       - The fitted parameters of the normal distribution.
'         e.g. for the above example, mean = 60, stddev = 20
'
' Return:
'   True if succesfully fitted, False if error.
'
' Example Usage:
'   Dim normMean As Double, normStdDev As Double
'   If MacroStats.FitNormalDistributionToData(60,0.5,80,0.84, normMean, normStdDev) Then
'       Debug.Print "Fitted! Mean [60] = "; normMean; ", SD [20] = "; normStdDev
'   Else
'       Debug.Print "Fitting error!"
'   End If
'
'------------------------------------------------------------------------------
    On Error GoTo normalFitError

    stddev = (X2 - X1) / _
             (WorksheetFunction.NormSInv(P2) - WorksheetFunction.NormSInv(P1))
             
    mean = (X1 * WorksheetFunction.NormSInv(P2) - X2 * WorksheetFunction.NormSInv(P1)) / _
           (WorksheetFunction.NormSInv(P2) - WorksheetFunction.NormSInv(P1))

    FitNormalDistributionToPercentiles = True
    Exit Function
    
normalFitError:
    mean = 0
    stddev = 0
    FitNormalDistributionToPercentiles = False
End Function

Public Function RandomFromNormal( _
    ByVal mean As Double, _
    ByVal stddev As Double _
) As Double
'------------------------------------------------------------------------------
' RandomFromNormal
' Uses Box-Mueller to generate a random normal number.
' Not the most efficient, but its accurate enough.
' More info:
'   - http://en.wikipedia.org/wiki/Normal_distribution
'       - "Generating values from normal distribution"
'
' Input:
'   mean as Double
'   stddev as Double
'       - The parameters of the normal distribution
'
' Return:
'   A random number from the distribution N(mean,stddev^2)
'
' Example Usage:
'   ' Generate 100 random numbers from a N(0,1) distribution
'   Dim normalData(1 To 100) As Double
'   For i = 1 To 100
'       normalData(i) = MacroStats.RandomFromNormal(0, 1)
'   Next i
'------------------------------------------------------------------------------
    
    Dim U As Double, V As Double
    U = 0: V = 0
    ' Rnd() can be exactly zero, which would break the Log()
    Do While U = 0: U = Rnd(): Loop
    Do While V = 0: V = Rnd(): Loop
    RandomFromNormal = (-2 * Log(Rnd())) ^ 0.5 * Sin(2 * MacroStatsPI * Rnd())
    RandomFromNormal = RandomFromNormal * stddev + mean
    
End Function


Public Function FitGammaDistributionToData( _
    ByRef data As Variant, _
    ByRef shapeP As Double, _
    ByRef scaleP As Double _
) As Boolean
'------------------------------------------------------------------------------
' FitGammaDistributionToData
' Fits a gamma distribution to a data set provided by the user.
' Uses Maximum Likelihood Estimation with Newton-Rhapson:
'   - http://en.wikipedia.org/wiki/Gamma_distribution
'           #Maximum_likelihood_estimation
'
' Input:
'   data As Variant
'       - A one dimensional array of numbers
'
' Output:
'   shapeP as Double
'   scaleP as Double
'       - The fitted parameters of the gamma distribution
'
' Return:
'   True if succesfully fitted, False if not possible.
'
' Example Usage:
'
'------------------------------------------------------------------------------
    On Error GoTo gammaFitError

    Dim i As Integer, n As Integer
    Dim k As Double
   
    ' Data size
    n = UBound(data) - LBound(data) + 1
   
    ' Calculate s as defined on the Wikipedia page
    Dim s As Double
    s = 0
    ' Step 1. Sum xi
    For i = 1 To n
        s = s + data(i)
    Next i
    ' Step 2. log(1/N sum xi)
    s = Log(s / n)
    ' Step 3. log(1/N sum xi) - 1/n sum ln xi
    For i = 1 To n
        s = s - 1 / n * Log(data(i))
    Next i
    
    ' Calculate shape parameter iteratively
    k = 1
    i = 0
    Dim nextK As Double, relChange As Double
    Do While True
        i = i + 1
        ' Check its actually converging
        If i = 100 Then Err.Raise vbObjectError
        
        ' Iterate
        nextK = k - (Log(k) - Digamma(k) - s) / (1 / k - Trigamma(k))
        
        ' Terminating condition
        relChange = Abs(nextK - k) / k
        
        k = nextK
        If relChange < 0.0001 Then Exit Do
    Loop
    shapeP = k
    
    ' Get scale parameter from shape (MLE)
    scaleP = 0
    For i = 1 To n
        scaleP = scaleP + (1 / (k * n)) * data(i)
    Next i
    
    FitGammaDistributionToData = True
    Exit Function
    
gammaFitError:
    shapeP = 0
    scaleP = 0
    FitGammaDistributionToData = False
End Function


Private Function Digamma(k As Double) As Double
'------------------------------------------------------------------------------
' Digamma
' Logarithmic derivative of the gamma function
' Used for fitting Gamma distribution.
' Source of this approximation: Choi and Wette (1969)
' via http://en.wikipedia.org/wiki/Gamma_distribution
'------------------------------------------------------------------------------
    Dim k2 As Double
    k2 = k * k
    
    If k < 8 Then
        Digamma = Digamma(k + 1) - 1 / k
    Else
        Digamma = Log(k) - (1 + (1 - (1 / 10 - 1 / (21 * k2)) / k2) / (6 * k)) / (2 * k)
    End If
End Function


Private Function Trigamma(k As Double) As Double
'------------------------------------------------------------------------------
' Trigamma
' Derivative of the digamma function
' Used for fitting Gamma distribution.
' Source of this approximation: Choi and Wette (1969)
' via http://en.wikipedia.org/wiki/Gamma_distribution
'------------------------------------------------------------------------------
    Dim k2 As Double
    k2 = k * k
    
    If k < 8 Then
        Trigamma = Trigamma(k + 1) + 1 / k2
    Else
        Trigamma = (1 + (1 + (1 - (1 / 5 - 1 / (7 * k2)) / k2) / (3 * k)) / (2 * k)) / k
    End If
End Function


Public Function FitGammaDistributionToPercentiles( _
    ByVal X1 As Double, ByVal P1 As Double, _
    ByVal X2 As Double, ByVal P2 As Double, _
    ByRef shapeP As Double, _
    ByRef scaleP As Double _
) As Boolean
'------------------------------------------------------------------------------
' FitGammaDistributionToPercentiles
' Fits a gamma distribution to two percentiles.
'   - http://www.johndcook.com/quantiles_parameters.pdf
'
' Input:
'   X1 as Double, P1 as Double
'   X2 as Double, P2 as Double
'       - Percentile #1 and #2, e.g.
'         50th percentile is 5000 => X1 = 5000, P1 = 0.5
'         84th percentile is 6500 >= X2 = 6500, P2 = 0.84
'
' Output:
'   shapeP as Double
'   scaleP as Double
'       - The fitted parameters of the gamma distribution.
'         e.g. for the above example, shape = 13.5, scale = 378.9
'
' Return:
'   True if succesfully fitted, False if error.
'
' Example Usage:
'   Dim gammaShape As Double, gammaScale As Double
'   If MacroStats.FitGammaDistributionToPercentiles(5000,0.5,6500,0.841,
'                                                   gammaShape, gammaScale) Then
'       Debug.Print "Fitted! Shape [13.5] = "; gammaShape; ", Scale [378.9] = "; gammaScale
'   Else
'       Debug.Print "Fitting error!"
'   End If
'
'------------------------------------------------------------------------------
    On Error GoTo gammaFitError

    ' Use bisection search to find roots of the equation
    ' Make sure LHS and RHS are opposite signs so we can start
    Dim LHS As Double, RHS As Double, MID As Double
    LHS = 1
    RHS = 1
    Do While GammaObj(LHS, X1, P1, X2, P2) < 0
        LHS = LHS / 2
    Loop
    Do While GammaObj(RHS, X1, P1, X2, P2) > 0
        RHS = RHS * 2
    Loop
    
    ' Begin root finding
    Do While Abs(RHS - LHS) > 0.001
        MID = (RHS + LHS) / 2
        If (GammaObj(LHS, X1, P1, X2, P2) * GammaObj(MID, X1, P1, X2, P2)) < 0 Then
            ' Bring in on RHS
            RHS = MID
        ElseIf (GammaObj(RHS, X1, P1, X2, P2) * GammaObj(MID, X1, P1, X2, P2)) < 0 Then
            ' Bring in on LHS
            LHS = MID
        Else
            ' MID is 0 -> done
            Exit Do
        End If
    Loop
    
    ' Turn into parameters
    shapeP = MID
    scaleP = X1 / WorksheetFunction.GammaInv(P1, shapeP, 1)
    
    FitGammaDistributionToPercentiles = True
    Exit Function
    
gammaFitError:
    shapeP = 0
    scaleP = 0
    FitGammaDistributionToPercentiles = False
End Function

'------------------------------------------------------------------------------
' GammaObj [PRIVATE]
' Used by FitGammaDistributionToPercentiles
'------------------------------------------------------------------------------
Private Function GammaObj(alpha, X1, P1, X2, P2)
    GammaObj = WorksheetFunction.GammaInv(P2, alpha, 1) / WorksheetFunction.GammaInv(P1, alpha, 1) - X2 / X1
End Function
